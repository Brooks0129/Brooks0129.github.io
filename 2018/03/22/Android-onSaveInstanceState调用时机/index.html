<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android onSaveInstanceState调用时机 · Hexo</title><meta name="description" content="Android onSaveInstanceState调用时机 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android onSaveInstanceState调用时机</h1><div class="post-info">Mar 22, 2018</div><div class="post-content"><p>最近项目中PM加了个需求，要做一个Android应用内通知，即当App在前台收到相应通知消息时，在屏幕顶部展示一个通知（并非系统Notification）。由于种种原因，最后技术选型将应用内通知选择作为一个activity，也就是在当前activity上弹出一个背景透明的activity。然后我发现下层的activity在onPause之后调用了onSaveInstanceState方法，why？难道onSaveInstanceState不是在activity异常销毁的时候才会调用吗？我们用onSaveInstanceState来保存activity状态，但是onSaveInstanceState真正的调用时机是什么？本文将对onSaveInstanceState方法的调用时机一探究竟。</p>
<p>##onSaveInstanceState介绍<br>首先看一下<a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle" target="_blank" rel="noopener">onSaveInstanceState</a>)官方API介绍。</p>
<blockquote>
<p>Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method will be passed to both).</p>
</blockquote>
<blockquote>
<p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via onCreate(Bundle) or onRestoreInstanceState(Bundle).</p>
</blockquote>
<blockquote>
<p>Do not confuse this method with activity lifecycle callbacks such as onPause(), which is always called when an activity is being placed in the background or on its way to destruction, or onStop() which is called before destruction. One example of when onPause() and onStop() is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState(Bundle) on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p>
</blockquote>
<blockquote>
<p>The default implementation takes care of most of the UI per-instance state for you by calling onSaveInstanceState() on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of onRestoreInstanceState(Bundle)). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself.</p>
</blockquote>
<blockquote>
<p>If called, this method will occur after onStop() for applications targeting platforms starting with P. For applications targeting earlier platform versions this method will occur before onStop() and there are no guarantees about whether it will occur before or after onPause().</p>
</blockquote>
<p>介绍有点长，我翻译了一下：</p>
<blockquote>
<p>在acitivty被销毁之前，该方法会被调用，用来存储每个实例的状态。这些信息存储在Bundle中，通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p>
</blockquote>
<blockquote>
<p>这个方法会在activity可能被销毁之前调用，如果将来activity回到了前台，就可以恢复它的状态。举个例子，如果activity A打开了Activity B，那么就有可能为了回收资源而导致Acitvity A被销毁，鉴于有这种情况出现，那么为了能让用户在将来再次回到Acitivty A时仍然能够看到之前的交互信息，就会调用onSaveInstanceState方法保存activity的状态。通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p>
</blockquote>
<blockquote>
<p>不要把这个方法与activity生命周期中的一些方法混淆了，onPause()会在acitivity且后台的时候被调用。什么时候onPause和onStop会调用，但是onSaveInstanseState不会调用呢？举个例子，当从Activity B回到Activity A后，由于B的状态不需要保存了，所以系统就不会调用onSaveInstanseState方法了。什么时候onPause会调用但是onSaveInstanseState不会调用呢？当Activity A上打开了Activity B后，如果A在B的生命周期内不会被销毁，那么A就不会调用onSaveInstanceState方法，A的用户交互信息仍将保持完整性。</p>
</blockquote>
<blockquote>
<p>该方法的默认实现存储了大部分UI的状态，存储了每个view及其对应的id（通过onRestoreInstanceState的默认实现可以将存储的信息恢复出来）。如果你覆盖了这个方法，想在这个方法里额外添加一些信息，那么最好调用下默认实现（super. onSaveInstanseState）,否则你就要自己来手动存储所有view的状态了。<br>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p>
</blockquote>
<p>虽然这段内容很长，但是都是满满的干货。大部分也都很好理解，不过我对下面这句话一直存在疑问，</p>
<blockquote>
<p>An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p>
</blockquote>
<p>Activity A打开了Activity B，真的可以保证Activity A在Activity B的生命周期内绝对不会被杀吗？如何绝对保证呢？如果无法保证，那么就一定会调用onSaveInstanceState吧。</p>
<p>简单来说，onSaveInstanceState作用就是在activity可能被销毁时被调用来存储activity的状态，然后可以在onCreate或者onRestoreInstanceState中恢复这些信息。</p>
<p>其实上面的介绍已经比较详细的说明了这个方法的调用时机，即：</p>
<blockquote>
<p>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p>
</blockquote>
<p>我们现在从源码的角度验证这一观点。我们验证的版本是Android 8.0（API 26）：</p>
<p>首先我们看下Activity.java中的onSaveInstanceState方法定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Activity.java</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, true);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplication().dispatchActivitySaveInstanceState(this, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法我们大概可以看到onSaveInstanceState这个方法保存了ui的信息和fragment的状态。那么我们看下activity<br>中调用该方法的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Activity.java</span><br><span class="line">final void performSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的performSaveInstanceState方法是由Instrumentation的callActivityOnSaveInstanceState方法调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Instrumentation.java</span><br><span class="line">public void callActivityOnSaveInstanceState(Activity activity, Bundle outState) &#123;</span><br><span class="line">    activity.performSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instrumentation的callActivityOnSaveInstanceState方法是由ActivityThread的callCallActivityOnSaveInstanceState方法调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ActivityThread.java</span><br><span class="line">private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</span><br><span class="line">    r.state = new Bundle();</span><br><span class="line">    r.state.setAllowFds(false);</span><br><span class="line">    if (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = new PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/22/hello-world/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>