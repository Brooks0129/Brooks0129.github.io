<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空心</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lisongda.com/"/>
  <updated>2018-03-31T09:58:40.307Z</updated>
  <id>http://lisongda.com/</id>
  
  <author>
    <name>李松达</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中TextView部分文字高亮及可点击</title>
    <link href="http://lisongda.com/2018/03/29/Android%E4%B8%ADTextView%E9%83%A8%E5%88%86%E6%96%87%E5%AD%97%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%8F%AF%E7%82%B9%E5%87%BB/"/>
    <id>http://lisongda.com/2018/03/29/Android中TextView部分文字高亮及可点击/</id>
    <published>2018-03-29T03:11:37.000Z</published>
    <updated>2018-03-31T09:58:40.307Z</updated>
    
    <content type="html"><![CDATA[<p>首先看下TextView如何实现部分文字高亮？</p><p>实现效果：</p><p><img src="/images/4.png" alt=""></p><p>这个很简单，利用h5标签就可以。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>&lt;![CDATA[你同意&lt;font color="#4AC7BA"&gt;用户协议&lt;/font&gt;吗?]]&gt;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"> CharSequence html = Html.fromHtml(getResources().getString(R.string.text));</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(html);</span><br></pre></td></tr></table></figure><p> 为什么要使用CDATA？使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。当然也可以不使用，那么string.xml中字符串应该为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> // string.xml</span><br><span class="line"> <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意&amp;lt;font color="#4AC7BA"&gt;用户协议&amp;lt;/font&gt;吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">  大于号和小于号都可以使用对应的转移字符来表示。`&amp;lt;对应 <span class="tag">&lt;<span class="name">``</span> &amp;<span class="attr">gt</span>;对应 &gt;</span>`</span><br><span class="line">  当然,&gt;也可以用相应的转义符表示。但是如果既不使用转义符，也不使用CDATA，只按照如下格式，是无法产生高亮效果的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ```xml</span><br><span class="line"> </span><br><span class="line">// string.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#4AC7BA"</span>&gt;</span>用户协议<span class="tag">&lt;/<span class="name">font</span>&gt;</span>吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式应该是最简单的一种实现部分文案高亮的方法。</p><p>但是现在如果要加个需求，高亮部分可以点击，非高亮部分不能点击呢？</p><p><strong>就要使用到SpannableString来实现了。</strong><br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line">   &lt;string name=&quot;text&quot;&gt;你同意用户协议吗?&lt;/string&gt;</span><br><span class="line">   &lt;string name=&quot;text_sub&quot;&gt;用户协议&lt;/string&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        setSpanTextInfo(textView, clickableSpan, getResources().getString(R.string.text), getResources().getString(R.string.text_sub));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSpanTextInfo</span><span class="params">(TextView textView, ClickableSpan clickableSpan, String fullTips, String spanTips)</span> </span>&#123;</span><br><span class="line">        SpannableString resultTipStr = <span class="keyword">new</span> SpannableString(fullTips);</span><br><span class="line">        <span class="keyword">int</span> start = fullTips.indexOf(spanTips);</span><br><span class="line">        <span class="keyword">int</span> end = start + spanTips.length();</span><br><span class="line">        <span class="keyword">int</span> defColor = Color.parseColor(<span class="string">"#4AC7BA"</span>);</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可点击</span></span><br><span class="line">            resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">            <span class="comment">// 高亮</span></span><br><span class="line">            resultTipStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(defColor), start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">        textView.setText(resultTipStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点需要注意的是：</p><ul><li>这里的高亮其实没有必要新创建一个ForegroundColorSpan，覆盖ClickableSpan的updateDrawState方法同样可以做到；</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        setSpanTextInfo(textView, clickableSpan, getResources().getString(R.string.text), getResources().getString(R.string.text_sub));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.updateDrawState(ds);</span><br><span class="line">            <span class="comment">// 高亮</span></span><br><span class="line">            ds.setColor(Color.parseColor(<span class="string">"#4AC7BA"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSpanTextInfo</span><span class="params">(TextView textView, ClickableSpan clickableSpan, String fullTips, String spanTips)</span> </span>&#123;</span><br><span class="line">        SpannableString resultTipStr = <span class="keyword">new</span> SpannableString(fullTips);</span><br><span class="line">        <span class="keyword">int</span> start = fullTips.indexOf(spanTips);</span><br><span class="line">        <span class="keyword">int</span> end = start + spanTips.length();</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可点击</span></span><br><span class="line">            resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">        textView.setText(resultTipStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其实刚开始的代码不是这样的，</p><p>刚开始的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮</span></span><br><span class="line">resultTipStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(defColor), start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">// 可点击</span></span><br><span class="line">resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br></pre></td></tr></table></figure><p>区别在哪里？就是这两行代码顺序反了，但是表现结果就出问题了，这里就不贴图了，表现为高亮部分的颜色变了，不是我们自己设置的颜色。这里查阅了一下官方文档，</p></li></ul><blockquote><p>The text with a ClickableSpan attached will be underlined and the link color will be used as a text color.<br>The default link color is the theme’s accent color or android:textColorLink if this attribute is defined in the theme. </p></blockquote><p> 即ClickableSpan是由默认颜色的，而且它覆盖了我们通过ForegroundColorSpan设置的颜色。</p><p> 我尝试在源码中找一下ClickableSpan是何时设置该颜色的，但是一直没有找到。。。。</p><ul><li><p>当我们在网上查看类似的代码时，其实大部分代码都跟如下相似：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpannableString string = <span class="keyword">new</span> SpannableString(<span class="string">"Text with clickable text"</span>);</span><br><span class="line">string.setSpan(<span class="keyword">new</span> CustomClickableSpan(), <span class="number">10</span>, <span class="number">19</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br></pre></td></tr></table></figure></li></ul><p>这样的代码有什么问题？java文件里字符串硬编码，应该放在string.xml里。当然这是小问题，因为这只是个例子嘛？但是更严重的问题就是当我们setSpan时起始位置和结束位置该如何确定呢？如果我们要适配多种语言，而不仅仅是中文和英文，该怎么做？比如我参与的项目是针对海外用户的产品，要适配20+的语言，当然是根据不同的文案来选择不同的位置，所以这里就不能把位置写死。</p><p> 就像大家刚开始看到的，我使用了两个字符串的方式来完成这项操作，大致意思是将需要高亮的部分单独提取出来成为一个文案，这样通过字符串匹配的方式来找到起始位置和结束位置。这种方式有没有什么缺点呢？理论上没有。但是在实际开发中却出现了问题。</p><p> 首先，我们要适配20+的语言，这个翻译工作不是由PM来完成的，而是交给第三方翻译公司完成。那么他们在翻译的时候，就经常出现两个字符串无法匹配的情况，即使我们已经明确强调了第二个字符串一定要是第一个字符串的子串，但是结果仍然不如人意，真的不知道他们的工作如何完成的。。。所以每次都需要RD来手动校验。如果出现了不匹配，就会导致高亮和点击效果失效。</p><p> 后来我们这边的RD提出了一个方案，即通过下面的方式就可以保证两个字符串一定会匹配上：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> // string.xml</span><br><span class="line"> &lt;string name=&quot;text&quot;&gt;你同意%s吗?&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;text_sub&quot;&gt;用户协议&lt;/string&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line">String child = getResources().getString(R.string.text_sub);</span><br><span class="line">String parent = getResources().getString(R.string.text, child);</span><br><span class="line">setSpanTextInfo(textView, clickableSpan, parent, child);</span><br></pre></td></tr></table></figure><p> 不知道大家看懂了没，就是把第一个字符串中需要高亮的部分提取出来，使用%s代替，再在java代码中替换回去，这样就可以保证第二个字符串一定是第一个字符串的子串，这样乍一看是不是很完美？但是它有个致命缺点。</p><p> 就是在做多语翻译的时候，有可能无法get到整个字符串的语意。举个例子，假设现在整个字符串为“你今天跟她打招呼了吗”，“打招呼”需要高亮可点击，那么使用最后的方案就是“你今天跟她%s了吗”，其实这句话的语意是不完整的，在翻译成其他语言的时候，有可能完全不知所云！当然，如果只是中文或英文，倒是没有什么问题。</p><p> 综上，还是采用，两个字符串匹配的方式，如果需要做多个国家的语言适配，那么还是推荐最原始的方案。<br> 即：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意用户协议吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text_sub"</span>&gt;</span>用户协议<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看下TextView如何实现部分文字高亮？&lt;/p&gt;
&lt;p&gt;实现效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个很简单，利用h5标签就可以。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="android" scheme="http://lisongda.com/tags/android/"/>
    
      <category term="TextView" scheme="http://lisongda.com/tags/TextView/"/>
    
  </entry>
  
  <entry>
    <title>一些小的Java&amp;Android知识点</title>
    <link href="http://lisongda.com/2018/03/27/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9A%84Java-Android%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://lisongda.com/2018/03/27/一些小的Java-Android知识点/</id>
    <published>2018-03-27T12:06:07.000Z</published>
    <updated>2018-03-28T08:31:58.137Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>==、equals方法和hashcode的区别</p><p>  <code>==</code>：当基本数据类型之间比较时，比较的是他们的值；否则比较的是他们在内存中的地址。</p><p>  <code>equals方法</code>：如果我们不覆盖Object中的equals方法，那么比较的是内存中的地址；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  当然我们可以根据具体的需求重写该方法。</p><p> <code>hashCode方法</code>：<br> equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的；hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的；对于大量需要比较的对象，如果调用equals()那么效率很低，所以先调用hashCode(）方法。如果hashCode()方法得到的值不一样，那么两个对象肯定不相等。如果hashCode()方法得到的值一样，那么再调用equals(）方法。这样会大大提高效率。  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;==、equals方法和hashcode的区别&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;==&lt;/code&gt;：当基本数据类型之间比较时，比较的是他们的值；否则比较的是他们在内存中的地址。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;equals方法&lt;/code&gt;：如果我们不覆盖Ob
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第三人称</title>
    <link href="http://lisongda.com/2018/03/27/%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0/"/>
    <id>http://lisongda.com/2018/03/27/第三人称/</id>
    <published>2018-03-27T04:58:31.000Z</published>
    <updated>2018-03-28T08:02:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>我爱的人最后都成了最恨我的人。</p><p>我无法忍受这种煎熬和痛苦，曾经天真的以为时间会抹平伤口，殊不知每次看到留下的伤疤仍然会如芒在背。所以我只能本能的反抗，我不能让伤痛吞噬掉自我，宁愿用愧疚去替代憎恨。</p><p>所以我做了，我反抗，我伤害了她，字幕画面分割上演碟对碟。爱与恨之间无非就是一个正负号的差别。</p><p>她骂我自私，说我变态，对我失望，但是我没得选择。在经历了不断地折磨之后，或许我还是很喜欢她，但是我们之间的爱情已经变质，我只想保护自己不再痛苦而已。</p><p>也许我只是个第三者，而谁是谁。</p><p>我对朋友说起这件事的时候，我问他，如果是你是我，你会做吗？他说也许不会，但是他的理由无法说服我，因为他毕竟不是我，他无法理解我的伤痛。</p><p>我一直觉得自己是个性情中人，想到什么就会去做。所以在感情中是个敏感且浪漫的人。经历了几段感情，我拥有的只有她们对我的憎恨，多么可悲。</p><p><img src="/images/3.JPG" alt="明信片"></p><p>我真的做了，我一步一步地成为了她最恨的人，她让我从她的生活中消失，说我的痛苦是活该。</p><p>结果是我确实没有那么恨她了，换来的是对她的愧疚和她对我的恨意。以前多么希望能看到她，跟她偶遇的时候我都觉得是上天的安排。可是现在我害怕面对她了。我始终没有对她道歉，没有说出那句对不起。也许我真的是混蛋。</p><p>对不起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我爱的人最后都成了最恨我的人。&lt;/p&gt;
&lt;p&gt;我无法忍受这种煎熬和痛苦，曾经天真的以为时间会抹平伤口，殊不知每次看到留下的伤疤仍然会如芒在背。所以我只能本能的反抗，我不能让伤痛吞噬掉自我，宁愿用愧疚去替代憎恨。&lt;/p&gt;
&lt;p&gt;所以我做了，我反抗，我伤害了她，字幕画面分割上演
      
    
    </summary>
    
      <category term="生活" scheme="http://lisongda.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://lisongda.com/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="生活" scheme="http://lisongda.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>推荐几首个人喜欢的歌</title>
    <link href="http://lisongda.com/2018/03/26/%E6%8E%A8%E8%8D%90%E5%87%A0%E9%A6%96%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E6%AD%8C/"/>
    <id>http://lisongda.com/2018/03/26/推荐几首个人喜欢的歌/</id>
    <published>2018-03-26T11:04:16.353Z</published>
    <updated>2018-03-28T08:02:52.658Z</updated>
    
    <content type="html"><![CDATA[<p>##空心<br>曾经跟别人说光泽的<a href="http://music.163.com/#/song?id=435288399" target="_blank" rel="noopener">空心</a>是我听过的最悲情的一首歌，其实我觉得在不同的心境下听歌感受是不同的。但是对于这首歌，无论何时听，内心其实都有一种莫名的压抑。想起自己经历的感情爱过的人，最后得到了什么，失去了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 光泽</span><br><span class="line">作词 : 姚若龙</span><br><span class="line">热爱曾是唯一的信仰</span><br><span class="line">相互凝望让对方捆绑</span><br><span class="line">在那时候简单的好傻</span><br><span class="line">却又空前绝后快乐啊</span><br><span class="line">直到现实狠狠推一把</span><br><span class="line">跌到浑身是伤疤</span><br><span class="line">你在欲望面前投降</span><br><span class="line">我在伤痛后面成长</span><br><span class="line">终于知道爱都有翅膀</span><br><span class="line">怎么拥抱它终究要飞翔</span><br><span class="line">漆黑空心也想被释放</span><br><span class="line">奈何思念比恨更顽强</span><br><span class="line">有个怀抱暖得像张床</span><br><span class="line">有份善良微笑多晴朗</span><br><span class="line">有一张唇美丽又疯狂</span><br><span class="line">为何爱谁心都空荡荡</span><br><span class="line">当我听说你跟他散场</span><br><span class="line">狼狈回家带着伤</span><br><span class="line">朋友都说那是惩罚</span><br><span class="line">我的心却多么痛啊</span><br><span class="line">虽然知道爱都有翅膀</span><br><span class="line">因为太爱所以会原谅</span><br><span class="line">漆黑空心也想被释放</span><br><span class="line">奈何思念比恨更顽强</span><br><span class="line">无法割舍就别怕感伤</span><br><span class="line">我也嫌我对你太滚烫</span><br><span class="line">深爱就像一种命一样</span><br><span class="line">没有任何方法能阻挡</span><br><span class="line">就算知道爱都有翅膀</span><br><span class="line">还是愿意让你停靠在我肩膀</span><br><span class="line">你也不用把我当作家</span><br><span class="line">把我当成一棵树吧</span><br></pre></td></tr></table></figure><p>##起风了</p><p><a href="http://music.163.com/#/song?id=461525011" target="_blank" rel="noopener">起风了</a>最近很火的一首歌，由<code>买辣椒也用券</code>翻唱第一次听是在看直播的时候，那个主播唱的很烂，但是歌曲本身真的超好听，尤其是对于一个独自在北京打拼的人来说，会有很多共鸣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 高橋優</span><br><span class="line">作词 : 米果</span><br><span class="line">原曲: ヤキモチ</span><br><span class="line">后期: 圣雨轻纱</span><br><span class="line">海报：不 咸</span><br><span class="line">这一路上走走停停 顺着少年漂流的痕迹</span><br><span class="line">迈出车站的前一刻 竟有些犹豫</span><br><span class="line">不禁笑这近乡情怯 仍无可避免</span><br><span class="line">而长野的天 依旧这么暖 风吹起了从前</span><br><span class="line">从前初识这世间 万般流连 看着天边似在眼前</span><br><span class="line">也甘愿赴汤蹈火去走它一遍</span><br><span class="line">如今走过这世间 万般流连 翻过岁月不同侧脸</span><br><span class="line">措不及防闯入你的笑颜</span><br><span class="line">我曾难自拔于世界之大 也沉溺于其中梦话 不得真假 不做挣扎 不惧笑话</span><br><span class="line">我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动 且就随缘去吧</span><br><span class="line">逆着光行走 任风吹雨打</span><br><span class="line">-M-</span><br><span class="line">短短的路走走停停 也有了几分的距离</span><br><span class="line">不知抚摸的是故事 还是段心情</span><br><span class="line">也许期待的不过是 与时间为敌</span><br><span class="line">再次看到你 微凉晨光里 笑的很甜蜜</span><br><span class="line">从前初识这世间 万般流连 看着天边似在眼前</span><br><span class="line">也甘愿赴汤蹈火去走它一遍</span><br><span class="line">如今走过这世间 万般流连 翻过岁月不同侧脸</span><br><span class="line">措不及防闯入你的笑颜</span><br><span class="line">我曾难自拔于世界之大 也沉溺于其中梦话 不得真假 不做挣扎 不惧笑话</span><br><span class="line">我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动 且就随缘去吧</span><br><span class="line">-=-</span><br><span class="line">晚风吹起你鬓间的白发 抚平回忆留下的疤 你的眼中 明暗交杂 一笑生花</span><br><span class="line">暮色遮住你蹒跚的步伐 走进床头藏起的画 画中的你 低着头说话</span><br><span class="line">我仍感叹于世界之大 也沉醉于儿时情话 不剩真假 不做挣扎 无谓笑话</span><br><span class="line">我终将青春还给了她 连同指尖弹出的盛夏 心之所动 就随风去了</span><br><span class="line">以爱之名 你还愿意吗</span><br><span class="line">-E-</span><br></pre></td></tr></table></figure><hr><p>由<code>起风了</code>了解到<code>买辣椒也用券</code>，接下来两首歌也都是她翻唱的。</p><p>##第三人称（Cover Hush！）</p><p><a href="http://music.163.com/#/song?id=502043537" target="_blank" rel="noopener">第三人称</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">作曲 : Hush</span><br><span class="line">作词 : Hush</span><br><span class="line">他想知道那是谁</span><br><span class="line">为何总沉默寡言</span><br><span class="line">人群中也算抢眼</span><br><span class="line">抢眼的孤独难免</span><br><span class="line"></span><br><span class="line">快乐当然有一点</span><br><span class="line">不过寂寞更强烈</span><br><span class="line">难过时候不流泪</span><br><span class="line">流泪也不算伤悲</span><br><span class="line"></span><br><span class="line">天真以为是他的独特品味</span><br><span class="line">殊不知是他</span><br><span class="line">难以言喻的对决</span><br><span class="line">字幕画面分割上演谍对谍</span><br><span class="line">而谁是谁</span><br><span class="line"></span><br><span class="line">对於第三人称的角度而言</span><br><span class="line">也明白其实</span><br><span class="line">每个人都有缺陷</span><br><span class="line"></span><br><span class="line">不自觉遮掩 多少也算</span><br><span class="line">自然的行为</span><br><span class="line"></span><br><span class="line">快乐当然有一点</span><br><span class="line">不过寂寞更强烈</span><br><span class="line">难过时候不流泪</span><br><span class="line">流泪也不算伤悲</span><br><span class="line"></span><br><span class="line">天真以为是他的独特品味</span><br><span class="line">殊不知是他</span><br><span class="line">难以言喻的对决</span><br><span class="line">字幕画面分割上演谍对谍</span><br><span class="line">而谁是谁</span><br><span class="line"></span><br><span class="line">对於第三人称的角度而言</span><br><span class="line">也明白其实</span><br><span class="line">每个人都有缺陷</span><br><span class="line">才不断的追寻 更好的自己</span><br><span class="line">直到青春一定程度的浪费</span><br><span class="line">才觉得可贵</span><br><span class="line"></span><br><span class="line">他想知道那是谁</span><br></pre></td></tr></table></figure><p>##联觉症</p><p><a href="http://music.163.com/#/song?id=427609608" target="_blank" rel="noopener">联觉症</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 陈粒 - 虚拟</span><br><span class="line">作词 : 央央</span><br><span class="line">Cover:辣椒</span><br><span class="line">《联觉症》</span><br><span class="line">形容虚无的声音</span><br><span class="line">耳畔温柔过叹息</span><br><span class="line">梦里面的白马有羽翼</span><br><span class="line">冰凉蒸腾的水滴</span><br><span class="line">坚硬无助的内心</span><br><span class="line">梦醒了那白马还未醒</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进了心里</span><br><span class="line">唯一我不敢靠近亲密的人就是你</span><br><span class="line">你比想象中还动人多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br><span class="line">数字加减的秘密</span><br><span class="line">对错涂抹几场戏</span><br><span class="line">眼前的繁锦难以言明</span><br><span class="line">热情滑落在池底</span><br><span class="line">疏离溯源是恐惧</span><br><span class="line">爱你的荒芜该对谁提</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进了心里</span><br><span class="line">唯一我不敢靠近亲密的人就是你</span><br><span class="line">你比想象中还动人多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进你心里</span><br><span class="line">我日夜都想靠近亲密的人就是你</span><br><span class="line">你轻描淡写的动人 多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##空心&lt;br&gt;曾经跟别人说光泽的&lt;a href=&quot;http://music.163.com/#/song?id=435288399&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;空心&lt;/a&gt;是我听过的最悲情的一首歌，其实我觉得在不同的心境下听歌感受是不同
      
    
    </summary>
    
      <category term="生活" scheme="http://lisongda.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Android onSaveInstanceState调用时机</title>
    <link href="http://lisongda.com/2018/03/22/Android-onSaveInstanceState%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/"/>
    <id>http://lisongda.com/2018/03/22/Android-onSaveInstanceState调用时机/</id>
    <published>2018-03-22T06:50:54.000Z</published>
    <updated>2018-03-29T03:21:05.679Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中PM加了个需求，要做一个Android应用内通知，即当App在前台收到相应通知消息时，在屏幕顶部展示一个通知（并非系统Notification）。由于种种原因，最后技术选型将应用内通知选择作为一个activity，也就是在当前activity上弹出一个背景透明的activity。然后我发现下层的activity在onPause之后调用了onSaveInstanceState方法，why？难道onSaveInstanceState不是在activity异常销毁的时候才会调用吗？我们用onSaveInstanceState来保存activity状态，但是onSaveInstanceState真正的调用时机是什么？本文将对onSaveInstanceState方法的调用时机一探究竟。</p><p>##onSaveInstanceState介绍<br>首先看一下<a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState%28android.os.Bundle%29" target="_blank" rel="noopener">onSaveInstanceState</a><br>官方API介绍。</p><blockquote><p>Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method will be passed to both).</p></blockquote><blockquote><p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via onCreate(Bundle) or onRestoreInstanceState(Bundle).</p></blockquote><blockquote><p>Do not confuse this method with activity lifecycle callbacks such as onPause(), which is always called when an activity is being placed in the background or on its way to destruction, or onStop() which is called before destruction. One example of when onPause() and onStop() is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState(Bundle) on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p></blockquote><blockquote><p>The default implementation takes care of most of the UI per-instance state for you by calling onSaveInstanceState() on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of onRestoreInstanceState(Bundle)). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself.</p></blockquote><blockquote><p>If called, this method will occur after onStop() for applications targeting platforms starting with P. For applications targeting earlier platform versions this method will occur before onStop() and there are no guarantees about whether it will occur before or after onPause().</p></blockquote><p>介绍有点长，我翻译了一下：</p><blockquote><p>在acitivty被销毁之前，该方法会被调用，用来存储每个实例的状态。这些信息存储在Bundle中，通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p></blockquote><blockquote><p>这个方法会在activity可能被销毁之前调用，如果将来activity回到了前台，就可以恢复它的状态。举个例子，如果activity A打开了Activity B，那么就有可能为了回收资源而导致Acitvity A被销毁，鉴于有这种情况出现，那么为了能让用户在将来再次回到Acitivty A时仍然能够看到之前的交互信息，就会调用onSaveInstanceState方法保存activity的状态。通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p></blockquote><blockquote><p>不要把这个方法与activity生命周期中的一些方法混淆了，onPause()会在acitivity且后台的时候被调用。什么时候onPause和onStop会调用，但是onSaveInstanseState不会调用呢？举个例子，当从Activity B回到Activity A后，由于B的状态不需要保存了，所以系统就不会调用onSaveInstanseState方法了。什么时候onPause会调用但是onSaveInstanseState不会调用呢？当Activity A上打开了Activity B后，如果A在B的生命周期内不会被销毁，那么A就不会调用onSaveInstanceState方法，A的用户交互信息仍将保持完整性。</p></blockquote><blockquote><p>该方法的默认实现存储了大部分UI的状态，存储了每个view及其对应的id（通过onRestoreInstanceState的默认实现可以将存储的信息恢复出来）。如果你覆盖了这个方法，想在这个方法里额外添加一些信息，那么最好调用下默认实现（super. onSaveInstanseState）,否则你就要自己来手动存储所有view的状态了。<br>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p></blockquote><p>虽然这段内容很长，但是都是满满的干货。大部分也都很好理解，不过我对下面这句话一直存在疑问，</p><blockquote><p>An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p></blockquote><p>Activity A打开了Activity B，真的可以保证Activity A在Activity B的生命周期内绝对不会被杀吗？如何绝对保证呢？如果无法保证，那么就一定会调用onSaveInstanceState吧。</p><p>简单来说，onSaveInstanceState作用就是在activity可能被销毁时被调用来存储activity的状态，然后可以在onCreate或者onRestoreInstanceState中恢复这些信息。</p><p>其实上面的介绍已经比较详细的说明了这个方法的调用时机，即：</p><blockquote><p>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p></blockquote><p>我们现在从源码的角度验证这一观点。我们验证的版本是Android 8.0（API 26）：</p><p>首先我们看下Activity.java中的onSaveInstanceState方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法我们大概可以看到onSaveInstanceState这个方法保存了ui的信息和fragment的状态。那么我们看下activity<br>中调用该方法的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onSaveInstanceState "</span> + <span class="keyword">this</span> + <span class="string">": "</span> + outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity的performSaveInstanceState方法是由Instrumentation的callActivityOnSaveInstanceState方法调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">    activity.performSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instrumentation的callActivityOnSaveInstanceState方法是由ActivityThread的callCallActivityOnSaveInstanceState方法调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    r.state = <span class="keyword">new</span> Bundle();</span><br><span class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到有四处调用了callCallActivityOnSaveInstanceState方法：</p><p><img src="/images/1.png" alt="&quot;callCallActivityOnSaveInstanceState调用&quot;"></p><p>下面详细介绍一下这四个方法，这样我们才知道activity在什么时候调用了该方法：</p><ul><li>performPauseActivity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">           r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Next have the activity save its current state and managed dialogs...</span></span><br><span class="line">       <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">           callCallActivityOnSaveInstanceState(r);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> !r.activity.mFinished &amp;&amp; saveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在performPauseActivity方法中，如果<code>!r.activity.mFinished &amp;&amp; saveState</code>为true，则会执行callCallActivityOnSaveInstanceState方法，然后才会执行performPauseActivityIfNeeded方法，在performPauseActivityIfNeeded方法里，调用了activity<br>的onPause方法。我们通过最开始介绍了解到，onSaveInstanceState方法的执行时机与onPause没有必然联系，但是这段代码却是在onPause之前执行的，是不是有点矛盾？那么我们来看下<code>!r.activity.mFinished &amp;&amp; saveState</code>究竟什么时候为true。首先看一下<code>r.activity.mFinished</code>这个变量，这个变量在activity<br>明确要finish的时候为true，比如我们手动调用了finish()方法；再看一下saveState变量，这里就不贴代码了，我们追溯的这个变量的源头可以发现saveState变量即是<code>activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB</code>的值，即判断targetSdkVersion是否小于11。所以到现在我们就知道了，如果我们的targetSdkVersion小于11，那么onSaveInstanceState方法确实可能在onPause之前调用。但是我们现在几乎所有项目的targetSdkVersion都大于11，所以其实几乎不会在该时候调用onSaveInstance方法。</p><ul><li>performStopActivityInner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">         StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing stop of "</span> + r);</span><br><span class="line">     <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">         performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Next have the activity save its current state and managed dialogs...</span></span><br><span class="line">         <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">             <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 callCallActivityOnSaveInstanceState(r);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!keepShown) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// Now we are idle.</span></span><br><span class="line">                 r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                             <span class="string">"Unable to stop activity "</span></span><br><span class="line">                             + r.intent.getComponent().toShortString()</span><br><span class="line">                             + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             r.stopped = <span class="keyword">true</span>;</span><br><span class="line">             EventLog.writeEvent(LOG_AM_ON_STOP_CALLED, UserHandle.myUserId(),</span><br><span class="line">                     r.activity.getComponentName().getClassName(), reason);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们看到在performStopActivityInner方法里首先执行了performPauseActivityIfNeeded，即再次保证了在onStop之前一定会调用onPause。然后判断是否应该调用callCallActivityOnSaveInstanceState，最后执行<code>r.activity.performStop(false /*preserveWindow*/);</code>，即调用activity<br>的onStop。那么这里的callCallActivityOnSaveInstanceState在什么情况下会执行呢？<code>r.activity.mFinished</code>变量与上面分析的一样，但是saveState有一些不同，我们我们现在来看下在什么情况下为true，</p><p><img src="/images/2.png" alt="&quot;saveState&quot;"></p><p>我们可以看到在第二个方法调用里，saveState为true，而且该方法是由handleStopActivity调用的，即当准备调用activity的onStop方法时，会调用ActivityThread<br>的handleStopActivity方法，此时如果<code>r.activity.mFinished</code>为false，会调用onSaveInstanceState方法。其实我们大部分时候看到的onSaveInstanceState方法调用都是在这个时候发生的。</p><ul><li>handleSleeping</li></ul><p>我们看下这个方法的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   // TODO: This method should be changed to use &#123;@link #performStopActivityInner&#125; to perform to</span><br><span class="line">    // stop operation on the activity to reduce code duplication and the chance of fixing a bug in</span><br><span class="line">    // one place and missing the other.</span><br><span class="line">    private void handleSleeping(IBinder token, boolean sleeping) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法里的逻辑跟performStopActivityInner方法里差不多，而且通过这个todo我们也可以看到本身这个方法里的逻辑就应该使用performStopActivityInner来完成。所以对这个方法我们就不做过多解释了。</p><ul><li>handleRelaunchActivity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRelaunchActivity</span><span class="params">(ActivityClientRecord tmp)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Need to ensure state is saved.</span></span><br><span class="line">      <span class="keyword">if</span> (!r.paused) &#123;</span><br><span class="line">          performPauseActivity(r.token, <span class="keyword">false</span>, r.isPreHoneycomb(), <span class="string">"handleRelaunchActivity"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (r.state == <span class="keyword">null</span> &amp;&amp; !r.stopped &amp;&amp; !r.isPreHoneycomb()) &#123;</span><br><span class="line">          callCallActivityOnSaveInstanceState(r);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      handleDestroyActivity(r.token, <span class="keyword">false</span>, configChanges, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      handleLaunchActivity(r, currentIntent, <span class="string">"handleRelaunchActivity"</span>);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>handleRelaunchActivity方法会在activity重新创建时调用，例如我们旋转了屏幕。我们可以看到首先调用了performPauseActivity方法，即activity<br>的onPause，然后调用callCallActivityOnSaveInstanceState犯法，即onSaveInstanceState，然后调用handleDestroyActivity方法完成activity<br>的销毁操作。乍一看是不是有点奇怪？onStop呢？在onSaveInstanceState和onDestory之间不是应该有个onStop吗？其实是在handleDestroyActivity里面，我们简单看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">                configChanges, getNonConfigInstance);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing finish of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityClass = r.activity.getClass();</span><br><span class="line">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.activity.performStop(r.mPreserveWindow);  <span class="comment">// ***here</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                                <span class="string">"Unable to stop activity "</span></span><br><span class="line">                                + safeToComponentShortString(r.intent)</span><br><span class="line">                                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.stopped = <span class="keyword">true</span>;</span><br><span class="line">                EventLog.writeEvent(LOG_AM_ON_STOP_CALLED, UserHandle.myUserId(),</span><br><span class="line">                        r.activity.getComponentName().getClassName(), <span class="string">"destroy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">                <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                        <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.window.closeAllPanels();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to destroy activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivities.remove(token);</span><br><span class="line">        StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样我们也可以看到在performDestroyActivity方法里，会判断activty的pause和stop状态是否执行过，如果没有，则会执行对应生命周期的方法，最后调用<code>mInstrumentation.callActivityOnDestroy(r.activity);</code>，即activity<br>的onDestory方法。<br>到这里我们基本就分析完了，总结起来就是：</p><blockquote><p>在Android P之前：<br>在targetSdkVersion小于11时，如果要执行onSaveInstanceState方法，则会在onPause之前执行。当targetSdkVersion大于等于11时，是在onPause之后执行的，但是都一定会在onStop之前。</p></blockquote><p>当然，按照文档中所说的，在Android P中，这个方法将在onStop()之后被调用。这个的分析以后待补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目中PM加了个需求，要做一个Android应用内通知，即当App在前台收到相应通知消息时，在屏幕顶部展示一个通知（并非系统Notification）。由于种种原因，最后技术选型将应用内通知选择作为一个activity，也就是在当前activity上弹出一个背景透明的a
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="onSaveInstanceState" scheme="http://lisongda.com/tags/onSaveInstanceState/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lisongda.com/2018/03/22/hello-world/"/>
    <id>http://lisongda.com/2018/03/22/hello-world/</id>
    <published>2018-03-22T02:51:18.615Z</published>
    <updated>2018-03-28T08:03:25.172Z</updated>
    
    <content type="html"><![CDATA[<p>这里是李松达的小屋，我将在这里分享个人的技术学习体会、生活情感心得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是李松达的小屋，我将在这里分享个人的技术学习体会、生活情感心得。&lt;/p&gt;

      
    
    </summary>
    
      <category term="hello" scheme="http://lisongda.com/categories/hello/"/>
    
    
  </entry>
  
</feed>
