<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空心</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lisongda.com/"/>
  <updated>2018-04-01T14:08:32.447Z</updated>
  <id>http://lisongda.com/</id>
  
  <author>
    <name>李瓶儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中常用线程介绍及对比</title>
    <link href="http://lisongda.com/2018/04/01/Android%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/"/>
    <id>http://lisongda.com/2018/04/01/Android中常用线程介绍及对比/</id>
    <published>2018-04-01T12:02:46.000Z</published>
    <updated>2018-04-01T14:08:32.447Z</updated>
    
    <content type="html"><![CDATA[<p>Android中需要用到线程的地方有很多，ThreadPool、AsyncTask、ThreadHandler和IntentService等，本文会对他们进行介绍和部分源码分析。</p><table><thead><tr><th>Thread name</th><th>Function</th></tr></thead><tbody><tr><td><a href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html" target="_blank" rel="noopener">ThreadPool</a></td><td>并行执行多个任务</td></tr><tr><td><a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="noopener">AsyncTask</a></td><td>worker Thread执行后台任务并将进度和结果传递给主线程中更新UI</td></tr><tr><td><a href="https://developer.android.com/reference/android/os/HandlerThread.html" target="_blank" rel="noopener">HandlerThread</a></td><td>一个包含Looper的Thread，在子线程中执行耗时的、可能有多个任务的操作</td></tr><tr><td><a href="https://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a></td><td>在后台执行耗时的异步任务，当任务完成后会自动停止，本质是Service</td></tr></tbody></table><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>重用线程池中的线程，避免线程创建和销毁带来的性能开销。</li><li>能有效控制线程池的最大并发数，避免大量线程之间因互相抢占系统资源而导致的阻塞现象。</li><li>能够对线程进行简单的管理，并且提供定时执行以及指定间隔循环执等功能。</li></ol><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>线程池的真正实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数，即使空闲状态也一直存活，除非allowCoreThreadTimeOut设置为true</li><li>maximumPoolSize：线程池容纳的最大线程数，当活动线程数达到这个数值之后，后续的新任务会阻塞</li><li>keepAliveTime：非核心线程闲置时的超时时长，超时后，会被回收</li><li>workQueue：线程池中的任务队列</li><li>threadFactory：线程工厂，为线程池提供新线程的功能。</li><li>handler：当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者。</li></ul><h3 id="ThreadPoolExecutor执行任务时大致遵循如下规则："><a href="#ThreadPoolExecutor执行任务时大致遵循如下规则：" class="headerlink" title="ThreadPoolExecutor执行任务时大致遵循如下规则："></a>ThreadPoolExecutor执行任务时大致遵循如下规则：</h3><ol><li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立即启动一个非核心线程来执行任务。</li><li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者。</li></ol><h3 id="AsyncTask中线程池的应用："><a href="#AsyncTask中线程池的应用：" class="headerlink" title="AsyncTask中线程池的应用："></a>AsyncTask中线程池的应用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"AsyncTask"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// We want at least 2 threads and at most 4 threads in the core pool,</span></span><br><span class="line">    <span class="comment">// preferring to have 1 less than the CPU count to avoid saturating</span></span><br><span class="line">    <span class="comment">// the CPU with background work</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                sPoolWorkQueue, sThreadFactory);</span><br><span class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的分类："><a href="#线程池的分类：" class="headerlink" title="线程池的分类："></a>线程池的分类：</h3><p>1.FixedThreadPool</p><blockquote><p>线程数量固定的线程池，当线程处于空闲状态时，他们并不会被回收，除非线程池被关闭。当所有线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2.CachedThreadPool</p><blockquote><p>线程数量不定的线程池，最大线程数为Integer.MAX_VALUE，这类线程池比较适合执行大量的耗时较少的任务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.ScheduledThreadPool</p><blockquote><p>它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当前非核心线程闲置时会被立即回收。主要用于执行定时任务和具有固定周期的重复任务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">    DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.SingleThreadExecutor</p><blockquote><p>线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。统一所有的外界任务到一个线程中，使得这些任务之间不需要处理线程同步的问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><h3 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h3><p>AsyncTask是一个轻量级的异步任务类。它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给朱线程中更新UI。从实现上来说，AsyncTask封装了Thread和Handler，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>三种泛型类型分别代表“启动任务执行的输入参数”、“后台任务执行的进度”、“后台计算结果的类型”。在特定场合下，并不是所有类型都被使用，如果没有被使用，可以用java.lang.Void类型代替。</p><p>一个异步任务的执行一般包括以下几个步骤：</p><ol><li><p>execute(Params… params)，执行一个异步任务，需要我们在代码中调用此方法，触发异步任务的执行。</p></li><li><p>onPreExecute()，在execute(Params… params)被调用后立即执行，一般用来在执行后台任务前对UI做一些标记。</p></li><li><p>doInBackground(Params… params)，在onPreExecute()完成后立即执行，用于执行较为费时的操作，此方法将接收输入参数和返回计算结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息。</p></li><li><p>onProgressUpdate(Progress… values)，在调用publishProgress(Progress… values)时，此方法被执行，直接将进度信息更新到UI组件上。</p></li><li><p>onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。 </p></li></ol><h3 id="AsyncTask源码解析："><a href="#AsyncTask源码解析：" class="headerlink" title="AsyncTask源码解析："></a>AsyncTask源码解析：</h3><p>从AsyncTask的execute方法开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the task with the specified parameters. The task returns</span></span><br><span class="line"><span class="comment"> * itself (this) so that the caller can keep a reference to it.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: this function schedules the task on a queue for a single background</span></span><br><span class="line"><span class="comment"> * thread or pool of threads depending on the platform version.  When first</span></span><br><span class="line"><span class="comment"> * introduced, AsyncTasks were executed serially on a single background thread.</span></span><br><span class="line"><span class="comment"> * Starting with &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#DONUT&#125;, this was changed</span></span><br><span class="line"><span class="comment"> * to a pool of threads allowing multiple tasks to operate in parallel. Starting</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#HONEYCOMB&#125;, tasks are back to being</span></span><br><span class="line"><span class="comment"> * executed on a single thread to avoid common application errors caused</span></span><br><span class="line"><span class="comment"> * by parallel execution.  If you truly want parallel execution, you can use</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #executeOnExecutor&#125; version of this method</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@link</span> #THREAD_POOL_EXECUTOR&#125;; however, see commentary there for warnings</span></span><br><span class="line"><span class="comment"> * on its use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params The parameters of the task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> This instance of AsyncTask.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@link</span> #getStatus()&#125; returns either</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> AsyncTask.Status#RUNNING&#125; or &#123;<span class="doctag">@link</span> AsyncTask.Status#FINISHED&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #executeOnExecutor(java.util.concurrent.Executor, Object[])</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #execute(Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line">    onPreExecute();</span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute方法和executeOnExecutor方法必须在主线程中调用，在Android1.6之前，AsyncTask是串行执行任务的。1.6开始采用线程池处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，Asynctask又采用了一个线程来串行执行任务。尽管如此，在Android3.0以及以后，我们可以通过AsyncTask的executeOnExecutor方法来并行的执行任务。<br>execute方法调用了executeOnExecutor方法，sDefaultExecutor是一个串行的线程池，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</span></span><br><span class="line"><span class="comment"> * order.  This serialization is global to a particular process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure><p>在executorOnExecutor中，onPreExecute方法最先执行，然后线程池开始执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">      Runnable mActive;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">          mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      r.run();</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      scheduleNext();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">              scheduleNext();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>//ToDo FutureTask解析</p><p>AsyncTask的Params参数封装为FutueTask对象，FutureTask是一个并发类。SerialExecutor的execute方法首先会吧FutureTask对象插入到任务队列mTasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext来执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完成后，AsyncTask会继续执行其他任务直到所有的任务都会被执行，默认情况下，AsyncTask是串行执行的。</p><p>AsyncTask中有两个线程池（SerialExecutor和<code>THREAD_POOL_EXECUTOR</code>）和一个Handler（InternalHandler），其中线程池SerialExecutor用于任务的排队，而线程池<code>THREAD_POOL_EXECUTOR</code>用于真正的执行任务，InternalThread用于将执行环境从线程池切换到主线程。</p><p>由于FutureTask的run方法会调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">         Result result = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">             <span class="comment">//noinspection unchecked</span></span><br><span class="line">             result = doInBackground(mParams);</span><br><span class="line">             Binder.flushPendingCommands();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">             mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">throw</span> tr;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             postResult(result);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>在mWorker的call方法中，首先mTaskInvoked设为true，表示当前任务已经被调用过了，然后执行doInBackground方法，接着将其返回值传递给postResult方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mHandler赋值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sHandler = <span class="keyword">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里获取的mHandler一定是主线程的handler的吗？通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到如果当前的callbackLooper为null或者是主线程的Looper的话，那么对应的handler就是主线程的handler，callbackLooper有没有可能为其他值呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造方法并不对外开放，所以handler一定为主线程的handler。这也就做到了线程的切换。</p><p>InternalHandler的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当sHandler收到<code>MESSAGE_POST_RESULT</code>消息时，会调用AsyncTask的finish方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AsyncTask注意事项："><a href="#AsyncTask注意事项：" class="headerlink" title="AsyncTask注意事项："></a>AsyncTask注意事项：</h3><p>1.AsyncTask中的所有任务将以串行的方式执行；</p><p>2.How to cancel task？<br>调用cancel方法：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">       mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">return</span> mFuture.cancel(mayInterruptIfRunning);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止更新进度</span></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">           getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                   <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 回调onCancelled方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">           onCancelled(result);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           onPostExecute(result);</span><br><span class="line">       &#125;</span><br><span class="line">       mStatus = Status.FINISHED;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p><code>mFuture.cancel(mayInterruptIfRunning);</code>会调用线程的interrupt方法。即使我们正确地调用了cancle() 也未必能真正地取消任务。因为如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，那么这个操作会继续下去。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断是否被取消</span></span><br><span class="line">   <span class="keyword">if</span>(isCancelled()) <span class="keyword">return</span>;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">doInBackground</span><span class="params">(Void... mgs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Task被取消了，马上退出</span></span><br><span class="line"><span class="keyword">if</span>(isCancelled()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.内存泄漏</p><p> 如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。</p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the identifier of this thread. See Process.myTid().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerThread和普通的Thread有显著的不同之处。普通Thread主要用于在run 方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。</p><p>HandlerThread的简单用法如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"MyHandlerThread"</span>);</span><br><span class="line">     handlerThread.start();</span><br><span class="line">     Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，可以用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，它的优先级要比单纯的线程高，所以IntentService比较适合执行一些高优先级的后台任务。它的onCreate方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceHandler的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntentService内部封装了HanderThread和Handler，当它被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。<br>每次启动IntentService，它的onStartCommand方法就会调用一次，IntentService在onStartCommand中处理每个后台任务的Intent。onStartCommand方法调用了onStart，onStart如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntentService通过mServiceHandler发送了一条消息，mServiceHandler收到消息后，会将Intent对象传递给onHandleIntent处理。当onHandleIntent方法结束后，IntentService会通过stopSelf(int startId)来尝试停止服务。stopSelf(int startId)会等待所有的消息都处理完毕后才终止服务；stopSelf()则会立即停止服务。<br>IntentService的onHandlerIntent方法是一个抽象方法，它的作用是从Intent的参数中区分具体的任务并执行这些任务。如果当前只存在一个任务，那么onHandleIntent方法执行完这个任务后，stopSelf(int startId)就会直接停止服务；如果目前存在多个任务，那么当onHandleIntent方法执行完最后一个任务，stopSelf(int startId)才会直接停止服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android中需要用到线程的地方有很多，ThreadPool、AsyncTask、ThreadHandler和IntentService等，本文会对他们进行介绍和部分源码分析。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Thread name&lt;/th&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="线程" scheme="http://lisongda.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android中TextView部分文字高亮及可点击</title>
    <link href="http://lisongda.com/2018/03/29/Android%E4%B8%ADTextView%E9%83%A8%E5%88%86%E6%96%87%E5%AD%97%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%8F%AF%E7%82%B9%E5%87%BB/"/>
    <id>http://lisongda.com/2018/03/29/Android中TextView部分文字高亮及可点击/</id>
    <published>2018-03-29T03:11:37.000Z</published>
    <updated>2018-03-31T10:08:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>首先看下TextView如何实现部分文字高亮？</p><p>实现效果：</p><p><img src="/images/4.png" alt=""></p><p>这个很简单，利用h5标签就可以。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>&lt;![CDATA[你同意&lt;font color="#4AC7BA"&gt;用户协议&lt;/font&gt;吗?]]&gt;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"> CharSequence html = Html.fromHtml(getResources().getString(R.string.text));</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(html);</span><br></pre></td></tr></table></figure><p> 为什么要使用CDATA？使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。当然也可以不使用，那么string.xml中字符串应该为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意&amp;lt;font color="#4AC7BA"&gt;用户协议&amp;lt;/font&gt;吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>  大于号和小于号都可以使用对应的转移字符来表示。<code>&amp;lt;对应 &lt;</code>,<code>&amp;gt;对应 &gt;</code><br>  当然,&gt;也可以用相应的转义符表示。但是如果既不使用转义符，也不使用CDATA，只按照如下格式，是无法产生高亮效果的。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#4AC7BA"</span>&gt;</span>用户协议<span class="tag">&lt;/<span class="name">font</span>&gt;</span>吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="comment">&lt;!--无法产生高亮效果--&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式应该是最简单的一种实现部分文案高亮的方法。</p><hr><p>但是现在如果要加个需求，高亮部分可以点击，非高亮部分不能点击呢？</p><p><strong>就要使用到SpannableString来实现了。</strong><br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line">   &lt;string name=&quot;text&quot;&gt;你同意用户协议吗?&lt;/string&gt;</span><br><span class="line">   &lt;string name=&quot;text_sub&quot;&gt;用户协议&lt;/string&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        setSpanTextInfo(textView, clickableSpan, getResources().getString(R.string.text), getResources().getString(R.string.text_sub));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSpanTextInfo</span><span class="params">(TextView textView, ClickableSpan clickableSpan, String fullTips, String spanTips)</span> </span>&#123;</span><br><span class="line">        SpannableString resultTipStr = <span class="keyword">new</span> SpannableString(fullTips);</span><br><span class="line">        <span class="keyword">int</span> start = fullTips.indexOf(spanTips);</span><br><span class="line">        <span class="keyword">int</span> end = start + spanTips.length();</span><br><span class="line">        <span class="keyword">int</span> defColor = Color.parseColor(<span class="string">"#4AC7BA"</span>);</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可点击</span></span><br><span class="line">            resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">            <span class="comment">// 高亮</span></span><br><span class="line">            resultTipStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(defColor), start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">        textView.setText(resultTipStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点需要注意的是：</p><ul><li>这里的高亮其实没有必要新创建一个ForegroundColorSpan，覆盖ClickableSpan的updateDrawState方法同样可以做到；</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        setSpanTextInfo(textView, clickableSpan, getResources().getString(R.string.text), getResources().getString(R.string.text_sub));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.updateDrawState(ds);</span><br><span class="line">            <span class="comment">// 高亮</span></span><br><span class="line">            ds.setColor(Color.parseColor(<span class="string">"#4AC7BA"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSpanTextInfo</span><span class="params">(TextView textView, ClickableSpan clickableSpan, String fullTips, String spanTips)</span> </span>&#123;</span><br><span class="line">        SpannableString resultTipStr = <span class="keyword">new</span> SpannableString(fullTips);</span><br><span class="line">        <span class="keyword">int</span> start = fullTips.indexOf(spanTips);</span><br><span class="line">        <span class="keyword">int</span> end = start + spanTips.length();</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可点击</span></span><br><span class="line">            resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">        textView.setText(resultTipStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其实刚开始的代码不是这样的，</p><p>刚开始的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮</span></span><br><span class="line">resultTipStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(defColor), start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">// 可点击</span></span><br><span class="line">resultTipStr.setSpan(clickableSpan, start, end, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br></pre></td></tr></table></figure><p>区别在哪里？就是这两行代码顺序反了，但是表现结果就出问题了，这里就不贴图了，表现为高亮部分的颜色变了，不是我们自己设置的颜色。这里查阅了一下官方文档，</p></li></ul><blockquote><p>The text with a ClickableSpan attached will be underlined and the link color will be used as a text color.<br>The default link color is the theme’s accent color or android:textColorLink if this attribute is defined in the theme. </p></blockquote><p> 即ClickableSpan是由默认颜色的，而且它覆盖了我们通过ForegroundColorSpan设置的颜色。</p><p> 我尝试在源码中找一下ClickableSpan是何时设置该颜色的，但是一直没有找到。。。。</p><ul><li><p>当我们在网上查看类似的代码时，其实大部分代码都跟如下相似：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpannableString string = <span class="keyword">new</span> SpannableString(<span class="string">"Text with clickable text"</span>);</span><br><span class="line">string.setSpan(<span class="keyword">new</span> CustomClickableSpan(), <span class="number">10</span>, <span class="number">19</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br></pre></td></tr></table></figure></li></ul><p>这样的代码有什么问题？java文件里字符串硬编码，应该放在string.xml里。当然这是小问题，因为这只是个例子嘛？但是更严重的问题就是当我们setSpan时起始位置和结束位置该如何确定呢？如果我们要适配多种语言，而不仅仅是中文和英文，该怎么做？比如我参与的项目是针对海外用户的产品，要适配20+的语言，当然是根据不同的文案来选择不同的位置，所以这里就不能把位置写死。</p><p> 就像大家刚开始看到的，我使用了两个字符串的方式来完成这项操作，大致意思是将需要高亮的部分单独提取出来成为一个文案，这样通过字符串匹配的方式来找到起始位置和结束位置。这种方式有没有什么缺点呢？理论上没有。但是在实际开发中却出现了问题。</p><p> 首先，我们要适配20+的语言，这个翻译工作不是由PM来完成的，而是交给第三方翻译公司完成。那么他们在翻译的时候，就经常出现两个字符串无法匹配的情况，即使我们已经明确强调了第二个字符串一定要是第一个字符串的子串，但是结果仍然不如人意，真的不知道他们的工作如何完成的。。。所以每次都需要RD来手动校验。如果出现了不匹配，就会导致高亮和点击效果失效。</p><p> 后来我们这边的RD提出了一个方案，即通过下面的方式就可以保证两个字符串一定会匹配上：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> // string.xml</span><br><span class="line"> &lt;string name=&quot;text&quot;&gt;你同意%s吗?&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;text_sub&quot;&gt;用户协议&lt;/string&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line">String child = getResources().getString(R.string.text_sub);</span><br><span class="line">String parent = getResources().getString(R.string.text, child);</span><br><span class="line">setSpanTextInfo(textView, clickableSpan, parent, child);</span><br></pre></td></tr></table></figure><p> 不知道大家看懂了没，就是把第一个字符串中需要高亮的部分提取出来，使用%s代替，再在java代码中替换回去，这样就可以保证第二个字符串一定是第一个字符串的子串，这样乍一看是不是很完美？但是它有个致命缺点。</p><p> 就是在做多语翻译的时候，有可能无法get到整个字符串的语意。举个例子，假设现在整个字符串为“你今天跟她打招呼了吗”，“打招呼”需要高亮可点击，那么使用最后的方案就是“你今天跟她%s了吗”，其实这句话的语意是不完整的，在翻译成其他语言的时候，有可能完全不知所云！当然，如果只是中文或英文，倒是没有什么问题。</p><p> 综上，还是采用，两个字符串匹配的方式，如果需要做多个国家的语言适配，那么还是推荐最原始的方案。<br> 即：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// string.xml</span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span>你同意用户协议吗?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"text_sub"</span>&gt;</span>用户协议<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看下TextView如何实现部分文字高亮？&lt;/p&gt;
&lt;p&gt;实现效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个很简单，利用h5标签就可以。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="android" scheme="http://lisongda.com/tags/android/"/>
    
      <category term="TextView" scheme="http://lisongda.com/tags/TextView/"/>
    
  </entry>
  
  <entry>
    <title>一些小的Java&amp;Android知识点</title>
    <link href="http://lisongda.com/2018/03/27/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9A%84Java-Android%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://lisongda.com/2018/03/27/一些小的Java-Android知识点/</id>
    <published>2018-03-27T12:06:07.000Z</published>
    <updated>2018-03-28T08:31:58.137Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>==、equals方法和hashcode的区别</p><p>  <code>==</code>：当基本数据类型之间比较时，比较的是他们的值；否则比较的是他们在内存中的地址。</p><p>  <code>equals方法</code>：如果我们不覆盖Object中的equals方法，那么比较的是内存中的地址；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  当然我们可以根据具体的需求重写该方法。</p><p> <code>hashCode方法</code>：<br> equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的；hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的；对于大量需要比较的对象，如果调用equals()那么效率很低，所以先调用hashCode(）方法。如果hashCode()方法得到的值不一样，那么两个对象肯定不相等。如果hashCode()方法得到的值一样，那么再调用equals(）方法。这样会大大提高效率。  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;==、equals方法和hashcode的区别&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;==&lt;/code&gt;：当基本数据类型之间比较时，比较的是他们的值；否则比较的是他们在内存中的地址。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;equals方法&lt;/code&gt;：如果我们不覆盖Ob
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第三人称</title>
    <link href="http://lisongda.com/2018/03/27/%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0/"/>
    <id>http://lisongda.com/2018/03/27/第三人称/</id>
    <published>2018-03-27T04:58:31.000Z</published>
    <updated>2018-04-01T09:37:52.581Z</updated>
    
    <content type="html"><![CDATA[<p>我爱的人最后都成了最恨我的人。</p><p>我无法忍受这种煎熬和痛苦，曾经天真的以为时间会抹平伤口，殊不知每次看到留下的伤疤仍然会如芒在背。所以我只能本能的反抗，我不能让伤痛吞噬掉自我，宁愿用愧疚去替代憎恨。</p><p>所以我做了，我反抗，我伤害了她，字幕画面分割上演碟对碟。爱与恨之间无非就是一个正负号的差别。</p><p>她骂我自私，说我变态，对我失望，但是我没得选择。在经历了不断地折磨之后，或许我还是很喜欢她，但是我们之间的爱情已经变质，我只想保护自己不再痛苦而已。</p><p>也许我只是个第三者，而谁是谁。</p><p>我对朋友说起这件事的时候，我问他，如果是你是我，你会做吗？他说也许不会，但是他的理由无法说服我，因为他毕竟不是我，他无法理解我的伤痛。</p><p>我一直觉得自己是个性情中人，想到什么就会去做。所以在感情中是个敏感且浪漫的人。经历了几段感情，我拥有的只有她们对我的憎恨，多么可悲。</p><p><img src="/images/3.JPG" alt="明信片"></p><p>我理想中的爱情是真诚浪漫美好的，不想把自己的心机用在最爱的人身上，但是我还是做了，我一步一步地成为了她最恨的人，她让我从她的生活中消失，说我的痛苦是活该。</p><p>结果是我确实没有那么恨她了，换来的是对她的愧疚和她对我的恨意。以前多么希望能看到她，跟她偶遇的时候我都觉得是上天的安排。可是现在我害怕面对她了。我始终没有对她道歉，没有说出那句对不起。也许我真的是混蛋。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p><p>对不起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我爱的人最后都成了最恨我的人。&lt;/p&gt;
&lt;p&gt;我无法忍受这种煎熬和痛苦，曾经天真的以为时间会抹平伤口，殊不知每次看到留下的伤疤仍然会如芒在背。所以我只能本能的反抗，我不能让伤痛吞噬掉自我，宁愿用愧疚去替代憎恨。&lt;/p&gt;
&lt;p&gt;所以我做了，我反抗，我伤害了她，字幕画面分割上演
      
    
    </summary>
    
      <category term="生活" scheme="http://lisongda.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://lisongda.com/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="生活" scheme="http://lisongda.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>推荐几首个人喜欢的歌</title>
    <link href="http://lisongda.com/2018/03/26/%E6%8E%A8%E8%8D%90%E5%87%A0%E9%A6%96%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E6%AD%8C/"/>
    <id>http://lisongda.com/2018/03/26/推荐几首个人喜欢的歌/</id>
    <published>2018-03-26T11:04:16.353Z</published>
    <updated>2018-04-01T14:09:09.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="空心"><a href="#空心" class="headerlink" title="空心"></a>空心</h2><p>曾经跟别人说光泽的<a href="http://music.163.com/#/song?id=435288399" target="_blank" rel="noopener">空心</a>是我听过的最悲情的一首歌，其实我觉得在不同的心境下听歌感受是不同的。但是对于这首歌，无论何时听，内心其实都有一种莫名的压抑。想起自己经历的感情爱过的人，最后得到了什么，失去了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 光泽</span><br><span class="line">作词 : 姚若龙</span><br><span class="line">热爱曾是唯一的信仰</span><br><span class="line">相互凝望让对方捆绑</span><br><span class="line">在那时候简单的好傻</span><br><span class="line">却又空前绝后快乐啊</span><br><span class="line">直到现实狠狠推一把</span><br><span class="line">跌到浑身是伤疤</span><br><span class="line">你在欲望面前投降</span><br><span class="line">我在伤痛后面成长</span><br><span class="line">终于知道爱都有翅膀</span><br><span class="line">怎么拥抱它终究要飞翔</span><br><span class="line">漆黑空心也想被释放</span><br><span class="line">奈何思念比恨更顽强</span><br><span class="line">有个怀抱暖得像张床</span><br><span class="line">有份善良微笑多晴朗</span><br><span class="line">有一张唇美丽又疯狂</span><br><span class="line">为何爱谁心都空荡荡</span><br><span class="line">当我听说你跟他散场</span><br><span class="line">狼狈回家带着伤</span><br><span class="line">朋友都说那是惩罚</span><br><span class="line">我的心却多么痛啊</span><br><span class="line">虽然知道爱都有翅膀</span><br><span class="line">因为太爱所以会原谅</span><br><span class="line">漆黑空心也想被释放</span><br><span class="line">奈何思念比恨更顽强</span><br><span class="line">无法割舍就别怕感伤</span><br><span class="line">我也嫌我对你太滚烫</span><br><span class="line">深爱就像一种命一样</span><br><span class="line">没有任何方法能阻挡</span><br><span class="line">就算知道爱都有翅膀</span><br><span class="line">还是愿意让你停靠在我肩膀</span><br><span class="line">你也不用把我当作家</span><br><span class="line">把我当成一棵树吧</span><br></pre></td></tr></table></figure><h2 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h2><p><a href="http://music.163.com/#/song?id=461525011" target="_blank" rel="noopener">起风了</a>最近很火的一首歌，由<code>买辣椒也用券</code>翻唱第一次听是在看直播的时候，那个主播唱的很烂，但是歌曲本身真的超好听，尤其是对于一个独自在北京打拼的人来说，会有很多共鸣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 高橋優</span><br><span class="line">作词 : 米果</span><br><span class="line">原曲: ヤキモチ</span><br><span class="line">后期: 圣雨轻纱</span><br><span class="line">海报：不 咸</span><br><span class="line">这一路上走走停停 顺着少年漂流的痕迹</span><br><span class="line">迈出车站的前一刻 竟有些犹豫</span><br><span class="line">不禁笑这近乡情怯 仍无可避免</span><br><span class="line">而长野的天 依旧这么暖 风吹起了从前</span><br><span class="line">从前初识这世间 万般流连 看着天边似在眼前</span><br><span class="line">也甘愿赴汤蹈火去走它一遍</span><br><span class="line">如今走过这世间 万般流连 翻过岁月不同侧脸</span><br><span class="line">措不及防闯入你的笑颜</span><br><span class="line">我曾难自拔于世界之大 也沉溺于其中梦话 不得真假 不做挣扎 不惧笑话</span><br><span class="line">我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动 且就随缘去吧</span><br><span class="line">逆着光行走 任风吹雨打</span><br><span class="line">-M-</span><br><span class="line">短短的路走走停停 也有了几分的距离</span><br><span class="line">不知抚摸的是故事 还是段心情</span><br><span class="line">也许期待的不过是 与时间为敌</span><br><span class="line">再次看到你 微凉晨光里 笑的很甜蜜</span><br><span class="line">从前初识这世间 万般流连 看着天边似在眼前</span><br><span class="line">也甘愿赴汤蹈火去走它一遍</span><br><span class="line">如今走过这世间 万般流连 翻过岁月不同侧脸</span><br><span class="line">措不及防闯入你的笑颜</span><br><span class="line">我曾难自拔于世界之大 也沉溺于其中梦话 不得真假 不做挣扎 不惧笑话</span><br><span class="line">我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动 且就随缘去吧</span><br><span class="line">-=-</span><br><span class="line">晚风吹起你鬓间的白发 抚平回忆留下的疤 你的眼中 明暗交杂 一笑生花</span><br><span class="line">暮色遮住你蹒跚的步伐 走进床头藏起的画 画中的你 低着头说话</span><br><span class="line">我仍感叹于世界之大 也沉醉于儿时情话 不剩真假 不做挣扎 无谓笑话</span><br><span class="line">我终将青春还给了她 连同指尖弹出的盛夏 心之所动 就随风去了</span><br><span class="line">以爱之名 你还愿意吗</span><br><span class="line">-E-</span><br></pre></td></tr></table></figure><hr><p>由<code>起风了</code>了解到<code>买辣椒也用券</code>，接下来两首歌也都是她翻唱的。</p><h2 id="第三人称（Cover-Hush！）"><a href="#第三人称（Cover-Hush！）" class="headerlink" title="第三人称（Cover Hush！）"></a>第三人称（Cover Hush！）</h2><p><a href="http://music.163.com/#/song?id=502043537" target="_blank" rel="noopener">第三人称</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">作曲 : Hush</span><br><span class="line">作词 : Hush</span><br><span class="line">他想知道那是谁</span><br><span class="line">为何总沉默寡言</span><br><span class="line">人群中也算抢眼</span><br><span class="line">抢眼的孤独难免</span><br><span class="line"></span><br><span class="line">快乐当然有一点</span><br><span class="line">不过寂寞更强烈</span><br><span class="line">难过时候不流泪</span><br><span class="line">流泪也不算伤悲</span><br><span class="line"></span><br><span class="line">天真以为是他的独特品味</span><br><span class="line">殊不知是他</span><br><span class="line">难以言喻的对决</span><br><span class="line">字幕画面分割上演谍对谍</span><br><span class="line">而谁是谁</span><br><span class="line"></span><br><span class="line">对於第三人称的角度而言</span><br><span class="line">也明白其实</span><br><span class="line">每个人都有缺陷</span><br><span class="line"></span><br><span class="line">不自觉遮掩 多少也算</span><br><span class="line">自然的行为</span><br><span class="line"></span><br><span class="line">快乐当然有一点</span><br><span class="line">不过寂寞更强烈</span><br><span class="line">难过时候不流泪</span><br><span class="line">流泪也不算伤悲</span><br><span class="line"></span><br><span class="line">天真以为是他的独特品味</span><br><span class="line">殊不知是他</span><br><span class="line">难以言喻的对决</span><br><span class="line">字幕画面分割上演谍对谍</span><br><span class="line">而谁是谁</span><br><span class="line"></span><br><span class="line">对於第三人称的角度而言</span><br><span class="line">也明白其实</span><br><span class="line">每个人都有缺陷</span><br><span class="line">才不断的追寻 更好的自己</span><br><span class="line">直到青春一定程度的浪费</span><br><span class="line">才觉得可贵</span><br><span class="line"></span><br><span class="line">他想知道那是谁</span><br></pre></td></tr></table></figure><h2 id="联觉症"><a href="#联觉症" class="headerlink" title="联觉症"></a>联觉症</h2><p><a href="http://music.163.com/#/song?id=427609608" target="_blank" rel="noopener">联觉症</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">作曲 : 陈粒 - 虚拟</span><br><span class="line">作词 : 央央</span><br><span class="line">Cover:辣椒</span><br><span class="line">《联觉症》</span><br><span class="line">形容虚无的声音</span><br><span class="line">耳畔温柔过叹息</span><br><span class="line">梦里面的白马有羽翼</span><br><span class="line">冰凉蒸腾的水滴</span><br><span class="line">坚硬无助的内心</span><br><span class="line">梦醒了那白马还未醒</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进了心里</span><br><span class="line">唯一我不敢靠近亲密的人就是你</span><br><span class="line">你比想象中还动人多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br><span class="line">数字加减的秘密</span><br><span class="line">对错涂抹几场戏</span><br><span class="line">眼前的繁锦难以言明</span><br><span class="line">热情滑落在池底</span><br><span class="line">疏离溯源是恐惧</span><br><span class="line">爱你的荒芜该对谁提</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进了心里</span><br><span class="line">唯一我不敢靠近亲密的人就是你</span><br><span class="line">你比想象中还动人多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br><span class="line">唯一我不能幻化成形的就是爱情</span><br><span class="line">它比想象中还透明还易委屈</span><br><span class="line">穿越悲喜覆在左肩 钻进你心里</span><br><span class="line">我日夜都想靠近亲密的人就是你</span><br><span class="line">你轻描淡写的动人 多么美丽</span><br><span class="line">随白马转啊转啊转 我该叹息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;空心&quot;&gt;&lt;a href=&quot;#空心&quot; class=&quot;headerlink&quot; title=&quot;空心&quot;&gt;&lt;/a&gt;空心&lt;/h2&gt;&lt;p&gt;曾经跟别人说光泽的&lt;a href=&quot;http://music.163.com/#/song?id=435288399&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="生活" scheme="http://lisongda.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Android onSaveInstanceState调用时机</title>
    <link href="http://lisongda.com/2018/03/22/Android-onSaveInstanceState%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/"/>
    <id>http://lisongda.com/2018/03/22/Android-onSaveInstanceState调用时机/</id>
    <published>2018-03-22T06:50:54.000Z</published>
    <updated>2018-04-01T14:09:30.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中PM加了个需求，要做一个Android应用内通知，即当App在前台收到相应通知消息时，在屏幕顶部展示一个通知（并非系统Notification）。由于种种原因，最后技术选型将应用内通知选择作为一个activity，也就是在当前activity上弹出一个背景透明的activity。然后我发现下层的activity在onPause之后调用了onSaveInstanceState方法，why？难道onSaveInstanceState不是在activity异常销毁的时候才会调用吗？我们用onSaveInstanceState来保存activity状态，但是onSaveInstanceState真正的调用时机是什么？本文将对onSaveInstanceState方法的调用时机一探究竟。</p><h2 id="onSaveInstanceState介绍"><a href="#onSaveInstanceState介绍" class="headerlink" title="onSaveInstanceState介绍"></a>onSaveInstanceState介绍</h2><p>首先看一下<a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState%28android.os.Bundle%29" target="_blank" rel="noopener">onSaveInstanceState</a><br>官方API介绍。</p><blockquote><p>Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method will be passed to both).</p></blockquote><blockquote><p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via onCreate(Bundle) or onRestoreInstanceState(Bundle).</p></blockquote><blockquote><p>Do not confuse this method with activity lifecycle callbacks such as onPause(), which is always called when an activity is being placed in the background or on its way to destruction, or onStop() which is called before destruction. One example of when onPause() and onStop() is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState(Bundle) on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p></blockquote><blockquote><p>The default implementation takes care of most of the UI per-instance state for you by calling onSaveInstanceState() on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of onRestoreInstanceState(Bundle)). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself.</p></blockquote><blockquote><p>If called, this method will occur after onStop() for applications targeting platforms starting with P. For applications targeting earlier platform versions this method will occur before onStop() and there are no guarantees about whether it will occur before or after onPause().</p></blockquote><p>介绍有点长，我翻译了一下：</p><blockquote><p>在acitivty被销毁之前，该方法会被调用，用来存储每个实例的状态。这些信息存储在Bundle中，通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p></blockquote><blockquote><p>这个方法会在activity可能被销毁之前调用，如果将来activity回到了前台，就可以恢复它的状态。举个例子，如果activity A打开了Activity B，那么就有可能为了回收资源而导致Acitvity A被销毁，鉴于有这种情况出现，那么为了能让用户在将来再次回到Acitivty A时仍然能够看到之前的交互信息，就会调用onSaveInstanceState方法保存activity的状态。通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)方法恢复实例的的状态。</p></blockquote><blockquote><p>不要把这个方法与activity生命周期中的一些方法混淆了，onPause()会在acitivity且后台的时候被调用。什么时候onPause和onStop会调用，但是onSaveInstanseState不会调用呢？举个例子，当从Activity B回到Activity A后，由于B的状态不需要保存了，所以系统就不会调用onSaveInstanseState方法了。什么时候onPause会调用但是onSaveInstanseState不会调用呢？当Activity A上打开了Activity B后，如果A在B的生命周期内不会被销毁，那么A就不会调用onSaveInstanceState方法，A的用户交互信息仍将保持完整性。</p></blockquote><blockquote><p>该方法的默认实现存储了大部分UI的状态，存储了每个view及其对应的id（通过onRestoreInstanceState的默认实现可以将存储的信息恢复出来）。如果你覆盖了这个方法，想在这个方法里额外添加一些信息，那么最好调用下默认实现（super. onSaveInstanseState）,否则你就要自己来手动存储所有view的状态了。<br>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p></blockquote><p>虽然这段内容很长，但是都是满满的干货。大部分也都很好理解，不过我对下面这句话一直存在疑问，</p><blockquote><p>An example when onPause() is called and not onSaveInstanceState(Bundle) is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState(Bundle) on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.</p></blockquote><p>Activity A打开了Activity B，真的可以保证Activity A在Activity B的生命周期内绝对不会被杀吗？如何绝对保证呢？如果无法保证，那么就一定会调用onSaveInstanceState吧。</p><p>简单来说，onSaveInstanceState作用就是在activity可能被销毁时被调用来存储activity的状态，然后可以在onCreate或者onRestoreInstanceState中恢复这些信息。</p><p>其实上面的介绍已经比较详细的说明了这个方法的调用时机，即：</p><blockquote><p>从android P开始，这个方法将在onStop()之后被调用。对于版本较低的系统，这个方法将在onStop之前调用，无法保证与onPause的先后调用顺序。</p></blockquote><p>我们现在从源码的角度验证这一观点。我们验证的版本是Android 8.0（API 26）：</p><p>首先我们看下Activity.java中的onSaveInstanceState方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法我们大概可以看到onSaveInstanceState这个方法保存了ui的信息和fragment的状态。那么我们看下activity<br>中调用该方法的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onSaveInstanceState "</span> + <span class="keyword">this</span> + <span class="string">": "</span> + outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity的performSaveInstanceState方法是由Instrumentation的callActivityOnSaveInstanceState方法调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">    activity.performSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instrumentation的callActivityOnSaveInstanceState方法是由ActivityThread的callCallActivityOnSaveInstanceState方法调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    r.state = <span class="keyword">new</span> Bundle();</span><br><span class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到有四处调用了callCallActivityOnSaveInstanceState方法：</p><p><img src="/images/1.png" alt="&quot;callCallActivityOnSaveInstanceState调用&quot;"></p><p>下面详细介绍一下这四个方法，这样我们才知道activity在什么时候调用了该方法：</p><ul><li>performPauseActivity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">           r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Next have the activity save its current state and managed dialogs...</span></span><br><span class="line">       <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">           callCallActivityOnSaveInstanceState(r);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> !r.activity.mFinished &amp;&amp; saveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在performPauseActivity方法中，如果<code>!r.activity.mFinished &amp;&amp; saveState</code>为true，则会执行callCallActivityOnSaveInstanceState方法，然后才会执行performPauseActivityIfNeeded方法，在performPauseActivityIfNeeded方法里，调用了activity<br>的onPause方法。我们通过最开始介绍了解到，onSaveInstanceState方法的执行时机与onPause没有必然联系，但是这段代码却是在onPause之前执行的，是不是有点矛盾？那么我们来看下<code>!r.activity.mFinished &amp;&amp; saveState</code>究竟什么时候为true。首先看一下<code>r.activity.mFinished</code>这个变量，这个变量在activity<br>明确要finish的时候为true，比如我们手动调用了finish()方法；再看一下saveState变量，这里就不贴代码了，我们追溯的这个变量的源头可以发现saveState变量即是<code>activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB</code>的值，即判断targetSdkVersion是否小于11。所以到现在我们就知道了，如果我们的targetSdkVersion小于11，那么onSaveInstanceState方法确实可能在onPause之前调用。但是我们现在几乎所有项目的targetSdkVersion都大于11，所以其实几乎不会在该时候调用onSaveInstance方法。</p><ul><li>performStopActivityInner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">         StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing stop of "</span> + r);</span><br><span class="line">     <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">         performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Next have the activity save its current state and managed dialogs...</span></span><br><span class="line">         <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">             <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 callCallActivityOnSaveInstanceState(r);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!keepShown) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// Now we are idle.</span></span><br><span class="line">                 r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                             <span class="string">"Unable to stop activity "</span></span><br><span class="line">                             + r.intent.getComponent().toShortString()</span><br><span class="line">                             + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             r.stopped = <span class="keyword">true</span>;</span><br><span class="line">             EventLog.writeEvent(LOG_AM_ON_STOP_CALLED, UserHandle.myUserId(),</span><br><span class="line">                     r.activity.getComponentName().getClassName(), reason);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们看到在performStopActivityInner方法里首先执行了performPauseActivityIfNeeded，即再次保证了在onStop之前一定会调用onPause。然后判断是否应该调用callCallActivityOnSaveInstanceState，最后执行<code>r.activity.performStop(false /*preserveWindow*/);</code>，即调用activity<br>的onStop。那么这里的callCallActivityOnSaveInstanceState在什么情况下会执行呢？<code>r.activity.mFinished</code>变量与上面分析的一样，但是saveState有一些不同，我们我们现在来看下在什么情况下为true，</p><p><img src="/images/2.png" alt="&quot;saveState&quot;"></p><p>我们可以看到在第二个方法调用里，saveState为true，而且该方法是由handleStopActivity调用的，即当准备调用activity的onStop方法时，会调用ActivityThread<br>的handleStopActivity方法，此时如果<code>r.activity.mFinished</code>为false，会调用onSaveInstanceState方法。其实我们大部分时候看到的onSaveInstanceState方法调用都是在这个时候发生的。</p><ul><li>handleSleeping</li></ul><p>我们看下这个方法的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   // TODO: This method should be changed to use &#123;@link #performStopActivityInner&#125; to perform to</span><br><span class="line">    // stop operation on the activity to reduce code duplication and the chance of fixing a bug in</span><br><span class="line">    // one place and missing the other.</span><br><span class="line">    private void handleSleeping(IBinder token, boolean sleeping) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法里的逻辑跟performStopActivityInner方法里差不多，而且通过这个todo我们也可以看到本身这个方法里的逻辑就应该使用performStopActivityInner来完成。所以对这个方法我们就不做过多解释了。</p><ul><li>handleRelaunchActivity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRelaunchActivity</span><span class="params">(ActivityClientRecord tmp)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Need to ensure state is saved.</span></span><br><span class="line">      <span class="keyword">if</span> (!r.paused) &#123;</span><br><span class="line">          performPauseActivity(r.token, <span class="keyword">false</span>, r.isPreHoneycomb(), <span class="string">"handleRelaunchActivity"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (r.state == <span class="keyword">null</span> &amp;&amp; !r.stopped &amp;&amp; !r.isPreHoneycomb()) &#123;</span><br><span class="line">          callCallActivityOnSaveInstanceState(r);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      handleDestroyActivity(r.token, <span class="keyword">false</span>, configChanges, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      handleLaunchActivity(r, currentIntent, <span class="string">"handleRelaunchActivity"</span>);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>handleRelaunchActivity方法会在activity重新创建时调用，例如我们旋转了屏幕。我们可以看到首先调用了performPauseActivity方法，即activity<br>的onPause，然后调用callCallActivityOnSaveInstanceState犯法，即onSaveInstanceState，然后调用handleDestroyActivity方法完成activity<br>的销毁操作。乍一看是不是有点奇怪？onStop呢？在onSaveInstanceState和onDestory之间不是应该有个onStop吗？其实是在handleDestroyActivity里面，我们简单看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">                configChanges, getNonConfigInstance);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing finish of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityClass = r.activity.getClass();</span><br><span class="line">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.activity.performStop(r.mPreserveWindow);  <span class="comment">// ***here</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                                <span class="string">"Unable to stop activity "</span></span><br><span class="line">                                + safeToComponentShortString(r.intent)</span><br><span class="line">                                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.stopped = <span class="keyword">true</span>;</span><br><span class="line">                EventLog.writeEvent(LOG_AM_ON_STOP_CALLED, UserHandle.myUserId(),</span><br><span class="line">                        r.activity.getComponentName().getClassName(), <span class="string">"destroy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">                <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                        <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.window.closeAllPanels();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to destroy activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivities.remove(token);</span><br><span class="line">        StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样我们也可以看到在performDestroyActivity方法里，会判断activty的pause和stop状态是否执行过，如果没有，则会执行对应生命周期的方法，最后调用<code>mInstrumentation.callActivityOnDestroy(r.activity);</code>，即activity<br>的onDestory方法。<br>到这里我们基本就分析完了，总结起来就是：</p><blockquote><p>在Android P之前：<br>在targetSdkVersion小于11时，如果要执行onSaveInstanceState方法，则会在onPause之前执行。当targetSdkVersion大于等于11时，是在onPause之后执行的，但是都一定会在onStop之前。</p></blockquote><p>当然，按照文档中所说的，在Android P中，这个方法将在onStop()之后被调用。这个的分析以后待补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目中PM加了个需求，要做一个Android应用内通知，即当App在前台收到相应通知消息时，在屏幕顶部展示一个通知（并非系统Notification）。由于种种原因，最后技术选型将应用内通知选择作为一个activity，也就是在当前activity上弹出一个背景透明的a
      
    
    </summary>
    
      <category term="技术" scheme="http://lisongda.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://lisongda.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="onSaveInstanceState" scheme="http://lisongda.com/tags/onSaveInstanceState/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lisongda.com/2018/03/22/hello-world/"/>
    <id>http://lisongda.com/2018/03/22/hello-world/</id>
    <published>2018-03-22T02:51:18.615Z</published>
    <updated>2018-03-28T08:03:25.172Z</updated>
    
    <content type="html"><![CDATA[<p>这里是李松达的小屋，我将在这里分享个人的技术学习体会、生活情感心得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是李松达的小屋，我将在这里分享个人的技术学习体会、生活情感心得。&lt;/p&gt;

      
    
    </summary>
    
      <category term="hello" scheme="http://lisongda.com/categories/hello/"/>
    
    
  </entry>
  
</feed>
